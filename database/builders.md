# Query Builders
As many other DB layers spiral provide way to construct basic SQL queries using set of generation classes. Such classes support fluent syntax which simplifies their usage in everyday applications.

## Before we start
Before we will start learning about different query builders let's try to create a table in our database first, we are going to use controller action for that:

```php
public function index(Database $database)
{
    $table = $database->table('test');

    $schema = $table->schema();
    $schema->primary('id');
    $schema->datetime('time_created');
    $schema->enum('status', ['active', 'disabled'])->defaultValue('active');
    $schema->string('name', 64);
    $schema->string('email');
    $schema->double('balance');
    $schema->save();
}
```

Once such table created, we can remove schema declaration and leave only table variable (instance `Spiral\Database\Entities\Table` or Table abstraction).

## Insert Builder
To get an instance of InsertBuilder (responsible for insertions), we can execute following code:

```php
$insert = $database->insert('test');
```

As result we will get builder associated with our table. Now we can add some values to our builder to be inserted into related table:

```php
$insert = $database->insert('test');

$insert->values([
    'time_created' => new \DateTime(),
    'name'         => 'Anton',
    'email'        => 'test@email.com',
    'balance'      => 800.90
]);
```

To run InsertQuery we should only execute method `run()` which will return last inserted id as result:

```php
dump($insert->run());
```

> You can also use fluent syntax: `$database->insert('table')->values(...)->run()`.

### Batch Insert
In many cases you might want to insert multiple records at once, we can achieve such goal with insert builder by specifying set of columns and values separatelly:

```php
$insert->columns(['time_created', 'name', 'email', 'balance']);
for ($i = 0; $i < 20; $i++) {
    //We don't need to specify key names in this case
    $insert->values([
        new \DateTime(),
        StringHelper::random(10),
        StringHelper::random(10) . '@email.com',
        mt_rand(0, 1000) / 10
    ]);
}

$insert->run();
```

### Quick Inserts
You can simplify insertion process by talking directly to Table absraction you want to add data into, in this case our code may look like:

```php
$table = $database->table('test');

dump($table->insert([
    'time_created' => new \DateTime(),
    'name'         => 'Anton',
    'email'        => 'test@email.com',
    'balance'      => 800.90
]));
```

> Table class will automatically run query and return last inserted id. You can also check `batchInsert` method of Table abstraction.

## Select Query Builder
SelectQuery builder can be retrieved two very similar ways, you can either get it from database or from table abstractions, let's try to show both examples (result are identical):

```php
public function index(Database $database)
{
    $table = $database->table('test');

    $select = $database->select()->from('test');
    $selectB = $table->select();
}
```

In our examples we will choose second appropach as it's shorter.

### Configuring and Reading selection
By default SelectQuery selects every column (`*`) from it's related table. We can always change set of requested columns using `columns` method.

```php
$select->columns(['id', 'status', 'name']);
```

Now, before jumping to where/having and other statements, let's figure out how to read data from our selection. DBAL component provides convinient `QueryResult` class which can help us to iterate thought result. We can receive such iterator either by calling `run()` method or by using `getIterator()` method. 

```php
$iterator = $select->getIterator();
foreach($iterator as $row) {
    dump($row);
}
```

In addition to that you can simply foreach over builder itself:

```php
foreach($select as $row) {
    dump($row);
}
```

> You can add such code to your action to view data created by insertion.

If you wish to preview SQL query generated by builder before executing it (after execution you can locate query in [Profiler] (/modules/profiler.md) logging tab) you can retrieve it via `queryString()` method or by simply dumping builder object. For example you might notice that DBAL automatically assigned table prefix.

```dump
dump($select->queryString());
```

> Attention! This query string is interpolated with parameters, you should ONLY use it for debudding/analyzation reasons. If you wish to see non interpolated query which will be sent to database with it's parameters - exectute `sqlStatement()` method.

### Where Statements
Obvisously, no query can useful if we can not specify where conditions. SeletQuery builder provides us such ability by declaric set of methods to generate where statement: `where`, `andWhere`, `orWhere`. Where methods can accept different arguments based on condition you want to create, but first argument is always dedicated to table identifier (column), you must never use it for user data. 

##### Basics
Let's add simple condition on `status` column of our table:

```php
public function index(Database $database)
{
    $select = $database->select()->from('test')->columns(['id', 'status', 'name']);

    $select->where('status', '=', 'active');

    foreach ($select as $row) {
        dump($row);
    }
}
```

Builder will generate following SQL for us:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE `status` = 'active'        
```

In cases were we want to use simple where statement with equal sign we can skip it as second argument, as result our where condition can be simplified:

```php
$select->where('status', 'active');
```

##### Where Operators
As you might expect, second argument can be used to declare operator:

```php
$select->where('id', '>', 10);
$select->where('status', 'like', 'active');
```

For between and not between conditions you can also use forth argument of where method:

```php
$select->where('id', 'between', 10, 20);
```

Resulted SQL:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE `id` BETWEEN 10 AND 20  
```

##### Multiple Where Conditions
As you might notice in previous example builder provides you ability to state multiple where conditions for one query, every new condtion will be joined to query based on it's modifier (AND or OR). Let's try to specify two AND coditions.

```php
$select->where('id', 1)->where('status', 'active');
```

Method `andWhere` is an alias for `where`, so we can rewrite such condition to make it more readable:

```php
$select->where('id', 1)->andWhere('status', 'active');
```

Resulted SQL will look like:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE `id` = 1 AND `status` = 'active'
```

Same way we can create OR conditions by using `orWhere` method (it has identical logic and set of arguments):

```php
$select->where('id', 1)->orWhere('id', 2)->orWhere*'status', 'active');
```

And our query changed to:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE `id` = 1 OR `id` = 2 OR `status` = 'active'
```

##### Complex/Group Where Conditions
So far we managed to create simple where statement, however in many cases we would need to group where conditions, this can be achieved by providing closure function with inner where statement inside our where or `orWhere` method. QueryBuilder will provide self as first argument into such function, let's check an example:

```php
$select->where('id', 1)->where(function (SelectQuery $select) {
    $select->where('status', 'active')->orWhere('id', 10);
});
```

Resulted SQL:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE `id` = 1 AND (`status` = 'active' OR `id` = 10)
```

Obviosly you can use `orWhere` to add grouped conditions:

```php
$select->where('id', 1)->orWhere(function (SelectQuery $select) {
    $select->where('status', 'active')->andWhere('id', 10);
});
```

Result:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE `id` = 1 OR (`status` = 'active' AND `id` = 10)     
```

> You can nest as many conditions as you want.

##### Simplified/array Where Conditions
Spiral where builders can additionally support simplified/array where conditions ([MongoDB style] (https://docs.mongodb.org/manual/reference/operator/query/)). Such definition can be really useful when you want to specify few short condition:

```php
$select->where([
    'id'     => 1,
    'status' => 'active'
]);
```

Such code is identical to two where method calls and generates such sql:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE (`id` = 1 AND `status` = 'active')
```

You can also specify custom comparasion operators using nested arrays:

```php
$select->where([
    'id'     => ['in' => [1, 2, 3]],
    'status' => ['like' => 'active']
]);
```

Resulted SQL:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE (`id` IN (1, 2, 3) AND `status` LIKE 'active')
```

Additionaly you can specify multiple compasation operations for one key:

```php
$select->where([
    'id' => [
        'in' => [1, 2, 3],
        '<'  => 100
    ]
]);
```

Array where syntax also allows you to use [MongoDB like] (https://docs.mongodb.org/manual/reference/operator/query/) conditions (@OR and @AND), such conditons can defined group with specified boolean joiner. Let's try to find every record where (ID is between 10 and 100 AND name equals Anton) OR (status is disabled), we can describe such condition using normal where statements:

```php
$select->where(function (SelectQuery $select) {
    $select->where('id', 'between', 10, 100)->andWhere('name', 'Anton');
})->orWhere('status', 'disabled');
```

Or we can use array syntax:

```php
$select->where([
    '@or' => [
        [
            'id'   => ['between' => [10, 100]],
            'name' => 'Anton'
        ],
        ['status' => 'disabled']
    ]
]);
```

In both cases resulted SQL will look like:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE ((`id` BETWEEN 10 AND 100 AND `name` = 'Anton') OR `status` = 'disabled')
```

You can experiment with both ways to declare where conditions and pick one you like more.

##### Parameters
Spiral does not support parameter binding at this moment, hovewer it provides an alternative way to set query parameters using special class `Spiral\Database\Injections\Parameter`. Let's try to parametrize id value and change it after forming our query:

```php
$select = $database->select()->from('test')->columns(['id', 'status', 'name']);

//You can also do: $select->where(['id' => $id = new Parameter(null)]);
$select->where('id', $id = new Parameter(null));

//Setting ID value
$id->setValue(15);

foreach ($select as $row) {
    dump($row);
}
```

Following methodic can be useful in cases where you would like to create some class wrapper at top of builder and expose it's parameters without rebuilding query every time.

> You can implement ParameterInterface if you want to decalare your own parameter wrappers, for example it will allow you to inject parametrized SQL code into query builder. This is possible due parameter reposible for both - mocking value or multiple values and providing placeholder for such values in query (see about injections below).

##### SQL Injections and Expressions

##### Sub/Nested Queries


##### Why do we need it?
write something clever
 
### Table and Column aliases
 
### Sorting

### Having

### Pagination

### Grouping and Distinct

### Joins

### Aggreagations

### Caching

## Update Query Builder

## Delete Query Builders