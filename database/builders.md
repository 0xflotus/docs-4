# Query Builders
As many other DB layers spiral provide way to construct basic SQL queries using set of generation classes. Such classes support fluent syntax which simplifies their usage in everyday applications.

## Before we start
Before we will start learning about different query builders let's try to create a table in our database first, we are going to use controller action for that:pa

```php
public function index(Database $database)
{
    $table = $database->table('test');

    $schema = $table->schema();
    $schema->primary('id');
    $schema->datetime('time_created');
    $schema->enum('status', ['active', 'disabled'])->defaultValue('active');
    $schema->string('name', 64);
    $schema->string('email');
    $schema->double('balance');
    $schema->save();
}
```

Once such table created, we can remove schema declaration and leave only table variable (instance `Spiral\Database\Entities\Table` or Table abstraction).

## Insert Builder
To get an instance of InsertBuilder (responsible for insertions), we can execute following code:

```php
$insert = $database->insert('test');
```

As result we will get builder associated with our table. Now we can add some values to our builder to be inserted into related table:

```php
$insert = $database->insert('test');

$insert->values([
    'time_created' => new \DateTime(),
    'name'         => 'Anton',
    'email'        => 'test@email.com',
    'balance'      => 800.90
]);
```

To run InsertQuery we should only execute method `run()` which will return last inserted id as result:

```php
dump($insert->run());
```

> You can also use fluent syntax: `$database->insert('table')->values(...)->run()`.

### Batch Insert
In many cases you might want to insert multiple records at once, we can achieve such goal with insert builder by specifying set of columns and values separatelly:

```php
$insert->columns(['time_created', 'name', 'email', 'balance']);
for ($i = 0; $i < 20; $i++) {
    //We don't need to specify key names in this case
    $insert->values([
        new \DateTime(),
        StringHelper::random(10),
        StringHelper::random(10) . '@email.com',
        mt_rand(0, 1000) / 10
    ]);
}

$insert->run();
```

### Quick Inserts
You can simplify insertion process by talking directly to Table absraction you want to add data into, in this case our code may look like:

```php
$table = $database->table('test');

dump($table->insert([
    'time_created' => new \DateTime(),
    'name'         => 'Anton',
    'email'        => 'test@email.com',
    'balance'      => 800.90
]));
```

> Table class will automatically run query and return last inserted id. You can also check `batchInsert` method of Table abstraction.

## Select Query Builder
SelectQuery builder can be retrieved two very similar ways, you can either get it from database or from table abstractions, let's try to show both examples (result are identical):

```php
public function index(Database $database)
{
    $table = $database->table('test');

    $select = $database->select()->from('test');
    $selectB = $table->select();
}
```

In our examples we will choose second appropach as it's shorter.

### Configuring and Reading selection
By default SelectQuery selects every column (`*`) from it's related table. We can always change set of requested columns using `columns` method.

```php
$select->columns(['id', 'status', 'name']);
```

Now, before jumping to where/having and other statements, let's figure out how to read data from our selection. DBAL component provides convinient `QueryResult` class which can help us to iterate thought result. We can receive such iterator either by calling `run()` method or by using `getIterator()` method. 

```php
$iterator = $select->getIterator();
foreach($iterator as $row) {
    dump($row);
}
```

In addition to that you can simply foreach over builder itself:

```php
foreach($select as $row) {
    dump($row);
}
```

> You can add such code to your action to view data created by insertion.

If you wish to preview SQL query generated by builder before executing it (after execution you can locate query in [Profiler] (/modules/profiler.md) logging tab) you can retrieve it via `queryString()` method or by simply dumping builder object. For example you might notice that DBAL automatically assigned table prefix.

```dump
dump($select->queryString());
```

> Attention! This query string is interpolated with parameters, you should ONLY use it for debudding/analyzation reasons. If you wish to see non interpolated query which will be sent to database with it's parameters - exectute `sqlStatement()` method.

### Where Statements
Obvisously, no query can useful if we can not specify where conditions. SeletQuery builder provides us such ability by declaric set of methods to generate where statement: `where`, `andWhere`, `orWhere`. Where methods can accept different arguments based on condition you want to create, but first argument is always dedicated to table identifier (column), you must never use it for user data. 

##### Basics
Let's add simple condition on `status` column of our table:

```php
public function index(Database $database)
{
    $select = $database->select()->from('test')->columns(['id', 'status', 'name']);

    $select->where('status', '=', 'active');

    foreach ($select as $row) {
        dump($row);
    }
}
```

Builder will generate following SQL for us:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE `status` = 'active'        
```

In cases were we want to use simple where statement with equal sign we can skip it as second argument, as result our where condition can be simplified:

```php
$select->where('status', 'active');
```

##### Where Operators
As you might expect, second argument can be used to declare operator:

```php
$select->where('id', '>', 10);
$select->where('status', 'like', 'active');
```

For between and not between conditions you can also use forth argument of where method:

```php
$select->where('id', 'between', 10, 20);
```

Resulted SQL:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE `id` BETWEEN 10 AND 20  
```

##### Multiple Where Conditions
As you might notice in previous example builder provides you ability to state multiple where conditions for one query, every new condtion will be joined to query based on it's modifier (AND or OR). Let's try to specify two AND coditions.

```php
$select->where('id', 1)->where('status', 'active');
```

Method `andWhere` is an alias for `where`, so we can rewrite such condition to make it more readable:

```php
$select->where('id', 1)->andWhere('status', 'active');
```

Resulted SQL will look like:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE `id` = 1 AND `status` = 'active'
```

Same way we can create OR conditions by using `orWhere` method (it has identical logic and set of arguments):

```php
$select->where('id', 1)->orWhere('id', 2)->orWhere*'status', 'active');
```

And our query changed to:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE `id` = 1 OR `id` = 2 OR `status` = 'active'
```

##### Complex/Group Where Conditions
So far we managed to create simple where statement, however in many cases we would need to group where conditions, this can be achieved by providing closure function with inner where statement inside our where or `orWhere` method. QueryBuilder will provide self as first argument into such function, let's check an example:

```php
$select->where('id', 1)->where(function (SelectQuery $select) {
    $select->where('status', 'active')->orWhere('id', 10);
});
```

Resulted SQL:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE `id` = 1 AND (`status` = 'active' OR `id` = 10)
```

Obviosly you can use `orWhere` to add grouped conditions:

```php
$select->where('id', 1)->orWhere(function (SelectQuery $select) {
    $select->where('status', 'active')->andWhere('id', 10);
});
```

Result:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE `id` = 1 OR (`status` = 'active' AND `id` = 10)     
```

> You can nest as many conditions as you want.

##### Simplified/array Where Conditions
Spiral where builders can additionally support simplified/array where conditions ([MongoDB style] (https://docs.mongodb.org/manual/reference/operator/query/)). Such definition can be really useful when you want to specify few short condition:

```php
$select->where([
    'id'     => 1,
    'status' => 'active'
]);
```

Such code is identical to two where method calls and generates such sql:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE (`id` = 1 AND `status` = 'active')
```

You can also specify custom comparasion operators using nested arrays:

```php
$select->where([
    'id'     => ['in' => [1, 2, 3]],
    'status' => ['like' => 'active']
]);
```

Resulted SQL:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE (`id` IN (1, 2, 3) AND `status` LIKE 'active')
```

Additionaly you can specify multiple compasation operations for one key:

```php
$select->where([
    'id' => [
        'in' => [1, 2, 3],
        '<'  => 100
    ]
]);
```

Array where syntax also allows you to use [MongoDB like] (https://docs.mongodb.org/manual/reference/operator/query/) conditions (@OR and @AND), such conditons can defined group with specified boolean joiner. Let's try to find every record where (ID is between 10 and 100 AND name equals Anton) OR (status is disabled), we can describe such condition using normal where statements:

```php
$select->where(function (SelectQuery $select) {
    $select->where('id', 'between', 10, 100)->andWhere('name', 'Anton');
})->orWhere('status', 'disabled');
```

Or we can use array syntax:

```php
$select->where([
    '@or' => [
        [
            'id'   => ['between' => [10, 100]],
            'name' => 'Anton'
        ],
        ['status' => 'disabled']
    ]
]);
```

In both cases resulted SQL will look like:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE ((`id` BETWEEN 10 AND 100 AND `name` = 'Anton') OR `status` = 'disabled')
```

You can experiment with both ways to declare where conditions and pick one you like more.

##### Parameters
Spiral does not support parameter binding at this moment, hovewer it provides an alternative way to set query parameters using special class `Spiral\Database\Injections\Parameter`. Let's try to parametrize id value and change it after forming our query:

```php
$select = $database->select()->from('test')->columns(['id', 'status', 'name']);

//You can also do: $select->where(['id' => $id = new Parameter(null)]);
$select->where('id', $id = new Parameter(null));

//Setting ID value
$id->setValue(15);

foreach ($select as $row) {
    dump($row);
}
```

> You can also pass requested PDO parameter type as second argument: `new Parameter(1, PDO::PARAM_INT)`.

Following methodic can be useful in cases where you would like to create some class wrapper at top of builder and expose it's parameters without rebuilding query every time.

> You can implement ParameterInterface if you want to decalare your own parameter wrappers, for example it will allow you to inject parametrized SQL code into query builder. This is possible due parameter reposible for both - mocking value or multiple values and providing placeholder for such values in query (see about injections below).

##### SQL Injections and Expressions
DBAL builders allow you to replace some of where statements with custom SQL code or expression. Such functionality achieved by two classes `SQLFragment` and `SQLExpression`. Let's try to review both of them to understand the difference.

Let's say we would like to compare our column value to DBMS specific function:

```php
//255
$select->where('id', '=', new SQLFragment("DAYOFYEAR('2015-09-12')"));
```

Resulted SQL will look exacly is needs to:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE `id` = DAYOFYEAR('2015-09-12')
```

You can not only use fragments as values for your identifiers, but as key itself:

```php
$select->where(new SQLExpression("DAYOFYEAR(concat('2015-09-', id))"), 255);
```

As result we can run complex statement against some column:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE DAYOFYEAR(concat('2015-09-', id)) = 255
```

The only problem in sql fragments is that table names will not be prefixed and column keys will be left unquoted, to solve such issue we can use alternative injector `SQLExpression`:

```php
$select->where(new SQLExpression("CONCAT(id, '-', status)"), '1-active');
```

Notice that know listed columns are quotes in resulted SQL:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE CONCAT(`id`, "-", `status`) = '1-active'
```

To demonstrate case when expressions are really useful let's edit our where statement a little bit as in case if we have multiple tables involved in one query (see joins and table aliases below):

```php
$select->where(new SQLExpression("CONCAT(test.id, '-', test.status)"), '1-active');
```

In this case DBAL detected usage of table name in our expression and applied valid table prefix:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE CONCAT(`primary_test`.`id`, '-', `primary_test`.`status`) = '1-active'
```

> Please remember that our database has table prefix "primary_", however there is high possiblity that you don't even need them ever. Also be careful using epressions with SQL including string constants, it will count your string as column to be quoted (such behaviour must be fixed in future).

You can also use expressions and fragments as column values in insert and update statements.

### Table and Column aliases
Based on previous example we found that expressions can be useful when we have to prepare complex column names, but what if we don't want to do that? In this case we can use default SQL feature - aliases. Aliases can be either applied to table or to column name and later be used in where, sorting and other statements. Spiral does not provide any special way to declare column or table alias, simply inlude "AS alias" into your column name or table. Let's try to demonstrate few examples:

```php
$select = $database->select()->from('test as abc')->columns([
    'id',
    'status',
    'name'
]);

$select->where('abc.id', '>', 10);

foreach ($select as $row) {
    dump($row);
}
```

Related SQL:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test` as `abc`
WHERE `abc`.`id` > 10
```

We can also rename some columns or create new one:

```php
$select = $database->select()->from('test')->columns([
    'id',
    'status as st',
    'name',
    "CONCAT(test.name, ' ', test.status) as name_and_status"
]);

foreach ($select as $row) {
    dump($row);
}
```

SQL:

```sql
SELECT
`id`, `status` as `st`, `name`, CONCAT(`primary_test`.`name`, ' ',`primary_test`.`status`) as `name_and_status`
FROM `primary_test`
```

> Aliases very useful with Joins (see below), in addition aliases used a lot of queries generated by spiral ORM.

##### Sub/Nested Queries
Every spiral QueryBuilder is as instance of `SQLFragmentInterface` which means you can freely use such sub queries as arugments in where methods. For example let's create some dummy query:

```php
$select = $database->select()->from('test')->columns(['id', 'status', 'name']);

$select->where(
    'id',
    'IN',
    $database->select('id')->from('test')->where('id', 'BETWEEN', 10, 100)
);

foreach ($select as $row) {
    dump($row);
}
```

And resulted SQL will look like:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE `id` IN  (SELECT
`id`
FROM `primary_test`
WHERE `id` BETWEEN 10 AND 100)  
```

As in cases with fragments and expressions you can use such sub query as where identifier and compare it with custom use data (or even leave it without any comparation if sub query returns boolean value).

```php
$select->where(
    $database->select('COUNT(*)')->from('test')->where('id', 'BETWEEN', 10, 100), '>', 1
);
```

Output:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE (SELECT
COUNT(*)
FROM `primary_test`
WHERE `id` BETWEEN 10 AND 100) > 1   
```

Following query does not have too much sense since we don't have connection between our query and sub query, we can add such connection by using `SQLExpression` class. In this example i'm going to use another table - `users`.

```php
$select = $database->select()->from('test')->columns(['id', 'status', 'name']);

$select->where(
    $database->select('name')->from('users')->where(
        'id', '=', new SQLExpression('test.id')
    )->where('id', '!=', 100),
    'Anton'
);

foreach ($select as $row) {
    dump($row);
}
```

Generated SQL must automatically apply prefix to our expression and link two tables together:

```sql
SELECT
`id`, `status`, `name`
FROM `primary_test`
WHERE (SELECT
`name`
FROM `primary_users`
WHERE `id` = `primary_test`.`id` AND `id` != 100) = 'Anton'
```

### Having
To add having satement to your selection use methods `having`, `orHaving` and `andHaving`, their declaration and behaviour is identical to `where`.
> Yep, it was quick.

### Joins
Previous example my explain you why everyone need joins. DBAL select query builer provides ability to join any desired table and specify ON and ON where statement. Let's try (i'm going to ajust way we creating our selection to make it shorter):

```php
$select = $database->table('test')->select(['test.*', 'users.name as user_name']);

//Let's join table users same way as before
$select->leftJoin('users')->on('users.id', 'test.id');

foreach ($select as $row) {
    dump($row);
}
```

> You can also use inner, full or right joins.

Result:

```sql
SELECT
`primary_test`.*, `primary_users`.`name` as `user_name`
FROM `primary_test`  
LEFT JOIN `primary_users`
    ON `primary_users`.`id` = `primary_test`.`id`
```

Method `on` works exacly as `where` except provided values treated as identifier and not as user value. As result we can use either complex `on` statements with `orOn`, `andOn` methods or array form of defining connection between tables.

```php
$select->leftJoin('users')->on('users.id', 'test.id')->orOn('users.id', 'test.balance');
```

Analog:

```sql
$select->leftJoin('users', [
    '@or' => [
        ['users.id' => 'test.id'],
        ['users.id' => 'test.balance']
    ]
]);
```

Generated SQL:

```sql
SELECT
`primary_test`.*, `primary_users`.`name` as `user_name`
FROM `primary_test`  
LEFT JOIN `primary_users`
    ON (`primary_users`.`id` = `primary_test`.`id` OR `primary_users`.`id` = `primary_test`.`balance`)    
```

##### On Where statement
In cases where you would like to include user value into ON statement, use methods `onWhere`, `orOnWhere` and `andOnWhere` (i'm going to change join to "inner" so we can filter our results):

```php
$select->innerJoin('users', ['users.id' => 'test.id'])->onWhere('users.name', 'Anton');
```

As result we just defined new query parameter:

```sql
SELECT
`primary_test`.*, `primary_users`.`name` as `user_name`
FROM `primary_test`  
INNER JOIN `primary_users`
    ON `primary_users`.`id` = `primary_test`.`id` AND `primary_users`.`name` = 'Anton'
```

##### Aliases
Obviously you might want to create custom alias for your joined table, and again you can do it by simply declaring word AS (do not forget to edit your columns and conditions):

```php
$select = $database->table('test')->select(['test.*', 'uu.name as user_name']);

//Let's join table users same way as before
$select->innerJoin('users as uu', ['uu.id' => 'test.id'])->onWhere('uu.name', 'Anton');

foreach ($select as $row) {
    dump($row);
}
```

And our final joins example looks like:

```sql
SELECT
`primary_test`.*, `uu`.`name` as `user_name`
FROM `primary_test`  
INNER JOIN `primary_users` as `uu`
    ON `uu`.`id` = `primary_test`.`id` AND `uu`.`name` = 'Anton'       
```

### Sorting
If you wish to apply sorting to your selection it's time to use method `orderBy` which can accept column name and sorting direction or array of columns associated with their directions.

```php
//We have a join, so table name is mandratory
$select->orderBy('test.id', SelectQuery::SORT_DESC);
```

You can all `orderBy` method multiple times or simply provide an array of columns into it:

```php
$select->orderBy(
    'test.name', SelectQuery::SORT_DESC
)->orderBy(
    'test.id', SelectQuery::SORT_ASC
);
        
//Analog
 $select->orderBy([
    'test.name' => SelectQuery::SORT_DESC,
    'test.id'   => SelectQuery::SORT_ASC
]);
```

Both ways will produce such SQL:

```sql
SELECT
`primary_test`.*, `uu`.`name` as `user_name`
FROM `primary_test`  
INNER JOIN `primary_users` as `uu`
    ON `uu`.`id` = `primary_test`.`id` AND `uu`.`name` = 'Anton' 
ORDER BY `primary_test`.`name` DESC, `primary_test`.`id` ASC
```

> You can also use SQLExpression or SQLFragment instead of sorting identifiers.

### Grouping and Distinct
If you wish to select only unique results from your selection use method `distinct`, such method will be very useful in situations where you using HAS_MANY relations in ORM to filter selection.

```php
$select->distinct();
```

To group results (for example in combination with aggregation) you can use method `groupBy` which accepts column name or SQLExpression, let's try to count our records in test table and group them by status:

```php
$select = $database->table('test')->select(['status', 'count(*) as count'])->groupBy('status');

foreach ($select as $row) {
    dump($row);
}
```

As you might expect produced SQL looks like:

```sql
SELECT
`status`, count(*) as `count`
FROM `primary_test`
GROUP BY `status`
```

### Aggreagations and Count
Separatelly from grouping and distinct you can use simplified aggregations which does not require you fetching result, one of them if `count`, which for many reasons will be used a lot in your application. To get result of such aggregation we only need to call method `count()`:

```php
$select = $database->table('test')->select(['id', 'name', 'status']);

dump($select->count());
foreach ($select as $row) {
    dump($row);
}
```

In this scenariou system will generate two separate SQL queries:

```sql
SELECT
COUNT(*)
FROM `primary_test`;

SELECT
`id`, `name`, `status`
FROM `primary_test`;
```

> You can also provide column name to be counted by.

Similar to `count()` SelectBuilder defines few additional methods you can use to calculate basic aggregations: `AVG`, `MAX`, `MIN` and `SUM`. You must only provide column name or expression to run aggregation by:

```php
dump($database->table('test')->sum('id'));
dump($database->table('test')->where('id', '<', 100)->max('id*10'));
```

### Pagination
When you working with big datasets you might want to limit amount of records to be returned, to do that you can use two simple SelectQuery methods: `limit` and `offset`

```php
$select = $database->table('test')->select(['id', 'name', 'status']);

$select->limit(10)->offset(1);

//Please note result of this method
dump($select->count());
foreach ($select as $row) {
    dump($row);
}
```

> Please note that count method will ignore specified LIMIT and OFFSET values by default (spiral will grant you additional parameter to avoid that in future).

However, there is very small chance that you going to work with `limit` and `offset` directly in your code as spiral provides much more convinient way - [Pagination] (/components/pagination.md). You can read pagination details in related section, hovewer let's try to modify our example to limit amount of results as 10 per page:

```php
$select = $database->table('test')->select(['id', 'name', 'status']);

$select->paginate(10);

foreach ($select as $row) {
    dump($row);
}
```

> You can change query parameter "page" in your website to iterate thought set.

### Caching
SelectQuery builder can store it's result in specified cache storage during requested time period. To enable caching for your selection, simply call method `cache` of your select builder. Method has only one mandratory argument - lifetime (seconds). In addition to that you can also provide desired cache key and cache store (in opposite case spiral will select key and store automatically).

```php
$select = $database->table('test')->select(['id', 'name', 'status'])->cache(10);
foreach ($select as $row) {
    dump($row);
}
```

If you have Pagination extension, you might notice that database query executed only once per 10 seconds, whan cache data expires.

## Update Query Builder
UpdateQuery builder as it states from it's name used to update specified records in table based on provided values and where conditions (set of where methods are identical to SelectQuery builder). We only have to execute `run()` method of our builder when we ready to perform query.

```php
$update = $database->table('test')->update([
    'name' => 'Abc'
]);

$update->where('id', '<', 10)->run();
```

Generated SQL (for MySQL) looks like:

```sql
UPDATE `primary_test`
SET `name` = 'Anb'
WHERE `id` < 10
```

As in cases with InsertQuery you can use `SQLExpressions` and `SQLFragments` as update values:

```php
$update = $database->table('test')->update([
    'name' => new SQLExpression('UPPER(test.name)')
]);

$update->where('id', '<', 10)->run();
```

Result:

```sql
UPDATE `primary_test`
SET `name` = UPPER(`primary_test`.`name`)
WHERE `id` < 10
```

You can also use nested queries:

```php
$update = $database->table('test')->update([
    'name' => $database->table('users')->select('name')->where('id', 1)
]);

$update->where('id', '<', 10)->run();
```

Related SQL:

```sql
UPDATE `primary_test`
SET `name` = (SELECT
`name`
FROM `primary_users`
WHERE `id` = 1)
WHERE `id` < 10 
```

## Delete Query Builders
DeleteQuery builder is probably the simpliest builder you can quess, you should only specify table you want to delete data from and set of where conditions in a same form as for select and update builders. You can access delete builder using Database or Table instances.

```php
$database->table('test')->delete()->where('id', '<', 1000)->run();
```

You can also specify where statement in Table `delete` method in a form of where array:

```php
$database->table('test')->delete([
    'id' => ['>' => 1000]
])->run();
```

## Why do we need query builders?
QueryBuilders (especially all this weird where statements) can seem useless as we still can write our queries in plain SQL, hovewer they will simplify your life a lot once you will start working with different DBMS or databases with non empty table prefixe and especially with ORM and pre-loading relations.

However, it's still the best to learn SQL as good as you can and check queries generated by Spiral in profiler logging tab to make sure that system is not fooling you.
