# Http Dispatcher Request flow
Spiral HTTP Component based on [PSR7](http://www.php-fig.org/psr/psr-7/) implenentation of http requests and responses, spiral utilizes [Zend implementation](https://github.com/zendframework/zend-diactoros) of such protocol as internal backbone. PSR7 makes dispatcher compatible with other frameworks,
middlewares and response generators.

## What is request
Spiral does not provide instance of "global" application request available in any place of application, instead of that it opens so called "request scope" and 
creates container binding `ServerRequestInterface` and "request" (for shortness) to access active request in controllers, request filters and services executed inside such scope. Once request performed and response is generated scope are closed and no instance of global request available anymore.

Due http dispatcher can be created in any environment it is possible to start application or nested request with custom instance of `ServerRequestInterface` at any
moment. Use dispatcher method "perform" to execute given request.

Let's view example how to call http perform method in controller using altered or custom request.

```php
protected function indexAction() {
    //This is going to be instance of request previously passed into http dispatcher method, 
    //not nesessary initial request
    $request = $this->request;
    
    //Let's change request uri path
    $uri = $request->getUri()->withPath("/new-path"); 
    
    //We are emulating user request 
    return $this->http->perform($request->withUri($uri));
}
```

> You can pass any implementation of `ServerRequestInterface` into `perform` method.

## What is Response
Spiral will hide instance of `ResponseInterface` passed int perform method, hovewer you can always get such object by declaring `ResponseInterface` dependency in your code. Let's try to alter set of headers generated by controller action:

```php
protected function indexAction(ResponseInterface $response)
{
    return $response->withHeader('Header', 'Some Value');
}
```

In addition to that, spiral allows you to return strings and arrays from your actions and enpoits (see below), such data will be written into active response body.

Technically, since both response and request are available via container you can count your Controllers as middleware:

```php
public function myAction(ServerRequestInterface $request, ResponseInterface $response)
{

}
```

## Middleware pipeline and endpoint (target)
Before request and response can be accessed inside controllers and other application services it will be passed thought set of [Http Middlewares] (middlewares.md) which can apply custom logic to filter request/response or even halt execution if some condition met (see `CsrfFilter` middleware).

After every middeware processed incoming request and response, such instances will be passed into so called "endpoint" which contains application logic, controllers and etc, endpoing should only be callable and accept `ServerRequestInterface` as first and `ResponseInterface` as second argument into `__invoke` method  (you can also use closures or custom methods (provided as array or class and method)). Request will be bindined (scope created) in container right before being passed into endpoint.

> If no custom endpoint provided, http dispatcher will use it's associated `Router` instance which will perform url routing to application controllers (actions).

Once endpoint (controller) generated response such responce will be converted into instance of `ResponseInterface` (for example if endpoint responded with string, such string will be writted to response previously passed thought every middleware). Response again will be passed thought every associated middleware in reverse order (for example to add nesesary headers) and then returned from `HttpDispatcher->perform()` method or automatically dispatched to client. Most of listed operations beformed inside `MiddlewarePipeline` class.

#### We can demonstrate request/response flow using well know image:
![middleware onion](http://stackphp.com/img/onion.png)

Where "Session" and "Authentication" treated as middlewares and "App" as endpoint.

## How HttpDispatcher works
HttpDispatcher has 3 notable methods we would like to check due they define our application backbone flow.

### Perform method
Method `perform` can be counted as blackbox accepting `ServerRequestInterface` as input and providing `ResponseInterface` as result (you can also provide your own instance of `ResponseInterface` as second argument, in opposite case Http will create response by it's own), interally every request will be passed thought set of middlewares (see above) as send to http endpoing (in default scenario this is http `Router`).

```php
$response = $http->perform($request);
```

### Dispatch method
Dispatch method used to send generated response back to client, it utilizes zend `EmitterInterface` which provides you ability to change way how reponses send to 
client browser or even store response in memory.

> It's not nesessary that application will stop after response were dispatched.

### Start method
Start method is Core constact implemented in every spiral dispatcher, it only must create response, perform it and send to client, let's view it's source for educational
purposes:
```php
public function start()
{
    $response = $this->perform(
        $this->request(),
        $this->response()
    );
    
    if (!empty($response)) {
        //Sending to client
        $this->dispatch($response);
    }
}
```
